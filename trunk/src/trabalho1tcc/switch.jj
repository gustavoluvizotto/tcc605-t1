/*  Projeto 1 - Teoria da Computação e Compiladores.
 *
 *  Gilberto Volpe Neto        6783993
 *  Gustavo Luvizotto Cesar    6783544
 *  Lucas Aoki Heredia         7174032
 */

options {
  LOOKAHEAD = 1;
  CHOICE_AMBIGUITY_CHECK = 2;
  OTHER_AMBIGUITY_CHECK = 1;
  STATIC = true;
  DEBUG_PARSER = false;
  DEBUG_LOOKAHEAD = false;
  DEBUG_TOKEN_MANAGER = false;
  ERROR_REPORTING = true;
  JAVA_UNICODE_ESCAPE = false;
  UNICODE_INPUT = false;
  IGNORE_CASE = false;
  USER_TOKEN_MANAGER = false;
  USER_CHAR_STREAM = false;
  BUILD_PARSER = true;
  BUILD_TOKEN_MANAGER = true;
  SANITY_CHECK = true;
  FORCE_LA_CHECK = false;
}

PARSER_BEGIN(Switch)
import java.io.PrintStream ;
public class Switch {

    public static void main(String args[]) {
        Switch parser = new Switch(System.in);
        while (true) {
            try {
                parser.Program(System.out);
            }   catch (ParseException e) {
                    System.out.println(e.getMessage());
                    System.exit(-1);
                }   catch (TokenMsgError e) {
                        System.out.println(e.getMessage());
                        System.exit(-1);
                    }
        }
    }
}
PARSER_END(Switch)

SKIP  : {" " | "\t" }
TOKEN : { < EOL : "\n" | "\r" | "\r\n" > }
TOKEN : { < LETTER : ["a"-"z","A"-"Z","_"] > }
TOKEN : { < DIGIT : ["0"-"9"] > }

TOKEN : { < PLUS : "+" > }
TOKEN : { < MINUS : "-" > }
TOKEN : { < TIMES : "*" > }
TOKEN : { < DIV: "/" > }
TOKEN : { < PERCENT : "%" > }

TOKEN : { < OPAR : "(" > }
TOKEN : { < CPAR : ")" > }
TOKEN : { < OBRA : "{" > }
TOKEN : { < CBRA : "}" > }

TOKEN : { < WHILE : "while" > }
TOKEN : { < IF : "if" > }
TOKEN : { < ELSE : "else" > }

TOKEN : { < SWITCH : "switch" > }
TOKEN : { < CASE: "case" > }
TOKEN : { < COLON : ":" > }
TOKEN : { < DEFLT: "default" > }
TOKEN : { < BREAK: "break" > }

TOKEN : { < INT: "int" > }
TOKEN : { < VOID: "void" > }

TOKEN : { < EQU : "==" > }
TOKEN : { < LEQU : "<=" > }
TOKEN : { < GEQU : ">=" > }
TOKEN : { < LESS : "<" > }
TOKEN : { < GREAT : ">" > }
TOKEN : { < NEQU : "!=" > }

TOKEN : { < NOT : "!" > }
TOKEN : { < AND : "&&" > }
TOKEN : { < OR : "||" > }

TOKEN : { < ASSIGN : "=" > }
TOKEN : { < COMMA : "," > }
TOKEN : { < SEMICOL : ";" > }

    void Program() :
    {
        String string;
        Token t;
    }
    {   
        ( VariableDeclaration() )* ProcedureDeclaration() 
        ( ProcedureDeclaration() )*
        <EOF>
    }

    void ProcedureDeclaration() :
    {
        String string;
        Token t;
    }
    {
        <VOID> ProcedureHeading() <OBRA> ProcedureBody() <CBRA>
    }

    void ProcedureBody() :
    {
        String string;
        Token t;
    }
    {
        (VariableDeclaration())* StatementSequence()
    }

    void ProcedureHeading() :
    {
        String string;
        Token t;
    }
    {
        Ident() <OPAR> (Parameter())? <CPAR>
    }

    void ParametersList() :
    {
        String string;
        Token t;
    }
    {
        Parameter() ( <COMMA> Parameter())*
    }

    void Parameter() :
    {
        String string;
        Token t;
    }
    {
        <INT> Ident()
    }

    void VariableDeclaration() :
    {
        String string;
        Token t;
    }
    {
        <INT> IdentList() <SEMICOL>
    }
    
    void IdentList() : 
    {
        String string;
        Token t;
    }
    {
        Ident() ( Assignment() )? ( <COMMA> IdentList() )*
    }

    void StatementSequence() : 
    {
        String string;
        Token t;
    }
    {
        ( Statement() )*
    }
    
    void LoopStatementSequence() : 
    {
        String string;
        Token t;
    }
    {
        ( Statement() | Break() )*
    }

    void Statement() :
    {
        String string;
        Token t;
    }
    {
        ( (Ident() (Assignment() | ProcedureCall() ) | WhileStatement() | 
        SelectionStatement() ) <SEMICOL> (<SEMICOL>)* )?
    }

    void WhileStatement() :
    {
        String string;
        Token t;
    }
    {
        <WHILE> <OPAR> Expression() <CPAR> <OBRA> LoopStatementSequence() <CBRA>
    }

    void SelectionStatement() :
    {
        String string;
        Token t;
    }
    {
        IfStatement() | SwitchStatement()
    }

    void SwitchStatement() :
    {
        String string;
        Token t;
    }
    {
        <SWITCH> <OPAR> Expression() <CPAR> <OBRA> (LoopStatementSequence())*
        (<CASE> ConstantExpression() <COLON> LoopStatementSequence())* 
        (<DEFLT> <COLON> LoopStatementSequence())? <CBRA>
    }
    
    void Break() :
    {
        String string;
        Token t;
    }
    {
        <BREAK> <SEMICOL>
    }

    void IfStatement() :
    {
        String string;
        Token t;
    }
    {
        <IF> <OPAR> Expression() <CPAR> <OBRA> LoopStatementSequence() <CBRA>
        (<ELSE> <OBRA> LoopStatementSequence() (Break())? <CBRA> )?
    }

    void ProcedureCall() :
    {
        String string;
        Token t;
    }
    {
        <OPAR> (ExpList())? <CPAR>
    }

    void ExpList() :
    {
        String string;
        Token t;
    }
    {
        Expression() (<COMMA> Expression())*
    }

    void Assignment() :
    {
        String string;
        Token t;
    }
    {
        <EQU> Expression()
    }

    void ConstantExpression() :
    {
        String string;
        Token t;
    }
    {
        ConstantOrExpr()
    }

    void ConstantOrExpr() :
    {
        String string;
        Token t;
    }
    {
        ConstantAndExpr() (<OR> ConstantAndExpr())?
    }

    void ConstantAndExpr() :
    {
        String string;
        Token t;
    }
    {
        ConstantEqualityExpr() ( <AND> ConstantEqualityExpr() )*
    }

    void ConstantEqualityExpr() :
    {
        String string;
        Token t;
    }
    {
        ConstantInequationExpr() ( ( <EQU> | <NEQU> ) ConstantInequationExpr() )?
    }

    void ConstantInequationExpr() :
    {
        String string;
        Token t;
    }
    {
        ConstantSimpleExpr() ( (<LESS> | <LEQU> | <GREAT> | <GEQU>) 
        ConstantSimpleExpr() )?
    }

    void ConstantSimpleExpr() :
    {
        String string;
        Token t;
    }
    {
        (<PLUS>)? ConstantTerm() ( (<PLUS> | <MINUS>) ConstantTerm() )*
    }

    void ConstantTerm() :
    {
        String string;
        Token t;
    }
    {
        ConstantUnary() ( (<TIMES> | <DIV> | <PERCENT>) ConstantUnary() )*
    }

    void ConstantUnary() :
    {
        String string;
        Token t;
    }
    {
        UnaryOperator() ConstantUnary() | ConstantFactor()
    }
    
    void ConstantFactor() : 
    {
        String string;
        Token t;
    }
    {
        Number() | <OPAR> ConstantExpression() <CPAR>
    }

    void Expression() :
    {
        String string;
        Token t;
    }
    {
            OrExpr()	
    }

    void OrExpr() :
    {
        String string;
        Token t;
    }
    {
            AndExpr() ( <OR> AndExpr() )*
    }

    void AndExpr() :
    {
        String string;
        Token t;
    }
    {
            EqualityExpr() ( <AND> EqualityExpr() )*
    }

    void EqualityExpr() :
    {
        String string;
        Token t;
    }
    {
            t = InequationExpr() ( ( <EQU> | <NEQU> ) InequationExpr() )?
            {
                string = t.image;
                return string;
            }    
    }

    String InequationExpr() :
    {
        String string;
        Token t;
        
    }
    {
           t = SimpleExpr() ( ( <LESS> | <LEQU> | <GREAT> | <GEQU> ) SimpleExpr() )?
           {
                string = t.image;
                return string;
           }
 
    }

    String SimpleExpr() :
    {
        String simpleExp_;
        Token  t_simpleExp;
    }
    {
            t_simpleExp = ( <PLUS> )? Term() ( ( <PLUS> | <MINUS> ) Term() )*
            {
                simpleExp_ = t_simpleExp.image;
                return simpleExp_;
            }
    }

    String Term() :
    {
        String term_;
        Token t_term;
    }
    {
            t_term = Unary() ( ( <TIMES> | <DIV> | <PERCENT> ) Unary() )*
            {
                term_ = t_term.image;
                return term_;
            }    
    }

    String Unary() :
    {
        String unary_;
        Token t_unary;
    }
    {
            t_unary = UnaryOperator() Unary() | Factor()
            {
                unary_ = t_unary;
                return unary_;
            }
    }

    String Factor() :
    {
        String factor_;
        Token t_factor;
    }
    {
            t_factor = Ident() | Number() | <OPAR> Expression() <CPAR>
            {
                factor_ = t_factor.image;
                return factor_;
            }    
    }

    String UnaryOperator() :
    {
        String unary_;
        Token t_unary;
    }
    {
            t_unary = <NOT> | <MINUS>
            {
                unary_ = t.image;
                return unary_;
            }
    }

    String Ident() :
    {
        String ident_;
        Token t_ident;
    }
    {
        

        t_ident = <LETTER> ( <LETTER> | <DIGIT> )*
        {  
            ident_ = t_ident.image;
            return ident_;
        }
    }
    
    String Number() : 
    {
        Integer number_;
        Token t_number;
        String s_number;
    }
    {
        t_number = <DIGIT> ( <DIGIT> )*
        {
            try{
                s_number = t_number.image;
                number_ = Integer.parseInt(s_number);
                if( number > 2147483648 )
                   throw new NumberFormatException(); 

                return s_number;    
            }
            catch(NumberFormatException n){
                System.out.println("JACA");
            } 
        }
    }

